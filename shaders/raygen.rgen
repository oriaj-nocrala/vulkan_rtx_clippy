// Advanced Ray Generation Shader - Full RTX Implementation

#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba16f) uniform image2D image;
layout(binding = 2, set = 0, rgba16f) uniform image2D accumulationBuffer;

layout(binding = 3, set = 0) uniform CameraProperties {
    mat4 model;
    mat4 view;
    mat4 proj;
    mat4 viewInverse;
    mat4 projInverse;
    vec3 cameraPos;
    float time;
    float metallic;
    float roughness;
    int rtxEnabled;
    vec2 mousePos;
    vec2 resolution;
    float glowIntensity;
    int frameCount;
    int maxBounces;
    int samplesPerPixel;
    int isBGRFormat; // 1 if BGR format, 0 if RGB
    float volumetricDensity;   // Fog/atmosphere density
    float volumetricScattering; // Light scattering strength
    float glassRefractionIndex; // Glass IOR (1.0 = air, 1.5 = glass)
    float causticsStrength;     // Caustics effect intensity
    float subsurfaceScattering; // SSS strength (0.0 = none, 1.0 = full)
    float subsurfaceRadius;     // SSS penetration distance
} cam;

// ðŸš€ PROFESSIONAL RAY PAYLOAD STRUCTURE - MATCH OTHER SHADERS
struct RayPayload {
    vec3 color;          // Final color result
    int depth;           // Current recursion depth  
    int rayType;         // 0=primary, 1=reflection, 2=shadow, 3=GI
    vec3 throughput;     // Energy throughput for path tracing
    uint flags;          // Debug and control flags
};

layout(location = 0) rayPayloadEXT RayPayload payload;

// Advanced random number generation
uint rngState;

uint wang_hash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

float rnd() {
    rngState = wang_hash(rngState);
    return float(rngState) / 4294967296.0;
}

vec2 rnd2() {
    return vec2(rnd(), rnd());
}

// Sample hemisphere for global illumination
vec3 cosineWeightedSample(vec3 normal) {
    vec2 r = rnd2();
    float phi = 2.0 * 3.14159265359 * r.x;
    float cosTheta = sqrt(r.y);
    float sinTheta = sqrt(1.0 - r.y);
    
    vec3 w = normal;
    vec3 u = normalize(cross((abs(w.x) > 0.1 ? vec3(0, 1, 0) : vec3(1, 0, 0)), w));
    vec3 v = cross(w, u);
    
    return normalize(u * cos(phi) * sinTheta + v * sin(phi) * sinTheta + w * cosTheta);
}

// Advanced ACES tone mapping
vec3 acesToneMapping(vec3 color) {
    const float A = 2.51;
    const float B = 0.03;
    const float C = 2.43;
    const float D = 0.59;
    const float E = 0.14;
    
    return (color * (A * color + B)) / (color * (C * color + D) + E);
}

// Temporal anti-aliasing jitter
vec2 getJitter() {
    uint pixelIndex = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
    uint seed = pixelIndex + cam.frameCount * 0x9e3779b9u;
    
    rngState = wang_hash(seed);
    return (rnd2() - 0.5) / vec2(gl_LaunchSizeEXT.xy);
}

// Depth of field effect
vec3 getDOFRayDirection(vec3 rayDir, vec3 rayOrigin) {
    float aperture = 0.05;
    float focalDistance = 6.0;
    
    // Focus point
    vec3 focusPoint = rayOrigin + rayDir * focalDistance;
    
    // Aperture disk sampling
    vec2 apertureSample = rnd2();
    float angle = apertureSample.x * 2.0 * 3.14159265359;
    float radius = sqrt(apertureSample.y) * aperture;
    
    vec3 apertureOffset = vec3(cos(angle) * radius, sin(angle) * radius, 0.0);
    vec3 newOrigin = rayOrigin + apertureOffset;
    vec3 newDirection = normalize(focusPoint - newOrigin);
    
    return newDirection;
}

// Motion blur effect
vec3 getMotionBlurredPosition(vec3 worldPos) {
    float motionBlurStrength = 0.02;
    float timeOffset = (rnd() - 0.5) * motionBlurStrength;
    float motionTime = cam.time + timeOffset;
    
    // Apply same motion as vertex shader
    vec3 motionPos = worldPos;
    float wave1 = sin(motionTime * 2.0 + worldPos.y * 3.0) * 0.05;
    float wave2 = sin(motionTime * 1.5 + worldPos.x * 2.0) * 0.03;
    float wave3 = cos(motionTime * 3.0 + worldPos.z * 4.0) * 0.02;
    
    motionPos.x += wave1 + wave2;
    motionPos.y += wave3;
    motionPos.z += wave1 * 0.5 + wave2 * 0.3;
    
    return motionPos;
}

void main() {
    const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    
    // ðŸŽ¯ PROFESSIONAL ANTI-ALIASING WITH MULTIPLE SAMPLES
    vec3 accumulatedColor = vec3(0.0);
    int actualSamples = max(1, cam.samplesPerPixel); // At least 1 sample
    
    // Initialize RNG for this pixel
    uint pixelIndex = pixel.y * gl_LaunchSizeEXT.x + pixel.x;
    rngState = wang_hash(pixelIndex + cam.frameCount * 0x9e3779b9u);
    
    for (int sampleIdx = 0; sampleIdx < actualSamples; sampleIdx++) {
        // Anti-aliasing jitter
        vec2 jitter = (actualSamples > 1) ? (rnd2() - 0.5) : vec2(0.0);
        vec2 pixelCenter = vec2(pixel) + vec2(0.5) + jitter;
        vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;
        
        // Generate camera ray
        vec4 origin = cam.viewInverse * vec4(0, 0, 0, 1);
        vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = normalize((cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz);
        
        // ðŸŽ­ ADVANCED CAMERA EFFECTS
        if (actualSamples > 1) {
            // Depth of field
            direction = getDOFRayDirection(direction, origin.xyz);
            
            // Motion blur for moving objects
            origin.xyz = getMotionBlurredPosition(origin.xyz);
        }
        
        // Ray tracing setup
        uint rayFlags = gl_RayFlagsOpaqueEXT;
        float tMin = 0.001;
        float tMax = 1000.0;
        
        // ðŸš€ INITIALIZE PRIMARY RAY PAYLOAD PROFESSIONALLY
        payload.color = vec3(0.0);        // Clear color
        payload.depth = 0;                // Primary ray starts at depth 0
        payload.rayType = 0;              // Primary ray type
        payload.throughput = vec3(1.0);   // Full energy throughput initially  
        payload.flags = uint(sampleIdx);     // Store sample index for debugging
        
        // ðŸŽ¯ DISPATCH PRIMARY RAY WITH INITIALIZED PAYLOAD
        traceRayEXT(topLevelAS, rayFlags, 0xff, 0, 0, 0, origin.xyz, tMin, direction, tMax, 0);
        
        // ðŸ”¬ ACCUMULATE SAMPLE RESULT
        accumulatedColor += payload.color;
    }
    
    // Average all samples
    vec3 finalColor = accumulatedColor / float(actualSamples);
    
    // ðŸŽ¨ ADVANCED TONE MAPPING
    finalColor = acesToneMapping(finalColor);
    
    // CONDITIONAL BGR CORRECTION: Only swap if BGR format detected
    if (cam.isBGRFormat == 1) {
        finalColor = finalColor.bgr; // Convert RGB -> BGR for BGR swapchain
    }
    
    // Output final color with conditional correction
    imageStore(image, pixel, vec4(finalColor, 1.0));
}