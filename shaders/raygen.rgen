// Advanced Ray Generation Shader - Full RTX Implementation

#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba16f) uniform image2D image;
layout(binding = 2, set = 0, rgba16f) uniform image2D accumulationBuffer;

layout(binding = 3, set = 0) uniform CameraProperties {
    mat4 model;
    mat4 view;
    mat4 proj;
    mat4 viewInverse;
    mat4 projInverse;
    vec3 cameraPos;
    float time;
    float metallic;
    float roughness;
    int rtxEnabled;
    vec2 mousePos;
    vec2 resolution;
    float glowIntensity;
    int frameCount;
    int maxBounces;
    int samplesPerPixel;
    int isBGRFormat; // 1 if BGR format, 0 if RGB
} cam;

layout(location = 0) rayPayloadEXT vec3 hitValue;
layout(location = 1) rayPayloadEXT vec3 reflectionValue;

// Advanced random number generation
uint rngState;

uint wang_hash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

float rnd() {
    rngState = wang_hash(rngState);
    return float(rngState) / 4294967296.0;
}

vec2 rnd2() {
    return vec2(rnd(), rnd());
}

// Sample hemisphere for global illumination
vec3 cosineWeightedSample(vec3 normal) {
    vec2 r = rnd2();
    float phi = 2.0 * 3.14159265359 * r.x;
    float cosTheta = sqrt(r.y);
    float sinTheta = sqrt(1.0 - r.y);
    
    vec3 w = normal;
    vec3 u = normalize(cross((abs(w.x) > 0.1 ? vec3(0, 1, 0) : vec3(1, 0, 0)), w));
    vec3 v = cross(w, u);
    
    return normalize(u * cos(phi) * sinTheta + v * sin(phi) * sinTheta + w * cosTheta);
}

// Advanced ACES tone mapping
vec3 acesToneMapping(vec3 color) {
    const float A = 2.51;
    const float B = 0.03;
    const float C = 2.43;
    const float D = 0.59;
    const float E = 0.14;
    
    return (color * (A * color + B)) / (color * (C * color + D) + E);
}

// Temporal anti-aliasing jitter
vec2 getJitter() {
    uint pixelIndex = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
    uint seed = pixelIndex + cam.frameCount * 0x9e3779b9u;
    
    rngState = wang_hash(seed);
    return (rnd2() - 0.5) / vec2(gl_LaunchSizeEXT.xy);
}

// Depth of field effect
vec3 getDOFRayDirection(vec3 rayDir, vec3 rayOrigin) {
    float aperture = 0.05;
    float focalDistance = 6.0;
    
    // Focus point
    vec3 focusPoint = rayOrigin + rayDir * focalDistance;
    
    // Aperture disk sampling
    vec2 apertureSample = rnd2();
    float angle = apertureSample.x * 2.0 * 3.14159265359;
    float radius = sqrt(apertureSample.y) * aperture;
    
    vec3 apertureOffset = vec3(cos(angle) * radius, sin(angle) * radius, 0.0);
    vec3 newOrigin = rayOrigin + apertureOffset;
    vec3 newDirection = normalize(focusPoint - newOrigin);
    
    return newDirection;
}

// Motion blur effect
vec3 getMotionBlurredPosition(vec3 worldPos) {
    float motionBlurStrength = 0.02;
    float timeOffset = (rnd() - 0.5) * motionBlurStrength;
    float motionTime = cam.time + timeOffset;
    
    // Apply same motion as vertex shader
    vec3 motionPos = worldPos;
    float wave1 = sin(motionTime * 2.0 + worldPos.y * 3.0) * 0.05;
    float wave2 = sin(motionTime * 1.5 + worldPos.x * 2.0) * 0.03;
    float wave3 = cos(motionTime * 3.0 + worldPos.z * 4.0) * 0.02;
    
    motionPos.x += wave1 + wave2;
    motionPos.y += wave3;
    motionPos.z += wave1 * 0.5 + wave2 * 0.3;
    
    return motionPos;
}

void main() {
    const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    const vec2 pixelCenter = vec2(pixel) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;
    
    // Generate camera ray
    vec4 origin = cam.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
    vec3 direction = normalize((cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz);
    
    // Simple single ray
    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin = 0.001;
    float tMax = 1000.0;
    
    traceRayEXT(topLevelAS, rayFlags, 0xff, 0, 0, 0, origin.xyz, tMin, direction, tMax, 0);
    
    // Use the hit value directly - NO CLAMPING TO PRESERVE GOLD!
    vec3 finalColor = hitValue; // Pure color from shaders
    
    // CONDITIONAL BGR CORRECTION: Only swap if BGR format detected
    if (cam.isBGRFormat == 1) {
        finalColor = finalColor.bgr; // Convert RGB -> BGR for BGR swapchain
    }
    
    // Output final color with conditional correction
    imageStore(image, pixel, vec4(finalColor, 1.0));
}